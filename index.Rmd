---
title: "projet_single_cell"
author: "Rahma BAAZIZ & Sandrine VRIGNON"
date: "2024-12-17"
output: html_document
---

## Installation library

```{r}
library(dplyr)
library(Seurat)
library (patchwork)
library (devtools)
library("BiocManager")
BiocManager::install("SingleCellSignalR")
```

## Visualisation des données

Les données à analyser ont été préalablement normalisées et sont donc comparables pour l'analyse. Il est toujours important de visualiser les données avant manipulation. Pour cela, nous avons décidé de visualiser le nombre de gènes détectés pour chaque cellule (nFeature_RNA), le nombre total de molécules détectées dans chaque cellule (nCount_RNA) et le pourcentage de mitochondrie dans la cellule (percent.mt).

```{r}
data<-readRDS("C://Users//sandr//OneDrive//Bureau//Cours fac//M2//Bioanalyse, transcriptomique//Single cell//dossier//myeloid-cells.RDS")
data[["percent.mt"]] <- PercentageFeatureSet(data, pattern="^MT-")  
VlnPlot(data, features=c("nFeature_RNA"), ncol=1)
VlnPlot(data, features=c("nCount_RNA"), ncol=1)
VlnPlot(data, features=c("percent.mt"), ncol=1)
```

Pour l'ensemble des cellules analysées, nous pouvons observer que les effectifs sont relativement élevés sauf dans le cas de HN28 et HN7 qui ont des effectifs plus faibles et cela pour l'ensemble des échantillons. Nous pouvons également observer que les données sont relativement bien réparties pour l'ensemble des échantillons nous permettant de dire que les cellules analysés sont dans l'ensemble en bon état (vivante et présente). Cependant lorsque l'on regarde le pourcentage de mitochondrie pour l'échantillon HN7 celui-ci à un taux compris entre 5 et 15% avec un peu plus de cellules dégradées.

```{r}
plot1 <- FeatureScatter(data, feature1="nCount_RNA", feature2="percent.mt")
plot2 <- FeatureScatter(data, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1+plot2
```

Lorsque l'on combine les données en confondant les types cellulaires, on observe mieux certaines valeurs extrêmes. Etant donné que les données ont été précédemment manipulées lors de la normalisation, nous supposons que celles-ci ont également été filtré avant normalisation. Ainsi nous ne filtreront pas les données dans notre cas et prenons l'ensemble de ces données à cette étape.

## Recherche de marqueur de type cellulaire

Afin de pouvoir déterminer les populations cellulaires spécifiques, nous recherchons les gènes avec une variabilité d'expression spécifique en fonction de la population cellulaire analysée. Nous avons choisi de garder les paramètres par défaut utilisant les 2000 caractéristiques de gène.

```{r}
data <- FindVariableFeatures(data, nfeatures=2000)
top15 <- head(VariableFeatures(data), 15)
top15

```

Ainsi nous pouvons ici répertorier les 15 premiers marqueurs spécifiques à nos population cellulaires.

```{r}
plot1 <- VariableFeaturePlot(data)
plot2 <- LabelPoints(plot=plot1, points=top15, repel=TRUE)
plot2
```

A travers ce graphique, nous pouvons ainsi observer que les marqueurs sélectionnés présentent bien des différences d'expression en fonction de la population cellulaire avec une variance résiduelle supérieure à 800 dans le cas de COL1A1 et des moyennes géométiques d'expression supérieures à 10.

Ces données vont ainsi être utilisées afin de permettre les analyses multiples et déterminer les caractéristiques de nos populations cellulaires *via* une ACP (Analyse en Composantes Principales) dans un premier temps.

## ACP

Afin de permettre la réalisation de notre ACP, nous avons réalisé une étape de pré-traitement des données grâce à une transfomation linéaire. Cette technique nous permettant d'effectuer une réduction dimentionnelle des données, donnant un poids égal sur les données d'expression en évitant certains biais sur les résultats.

Les données ont ensuite été centrées et reduites en utilisant une table matricielle

```{r}
all.genes <- rownames(data)
data <- ScaleData(data, features=all.genes)
data <- RunPCA(data, features=VariableFeatures(data), ndims.print=1:3, nfeatures.print=10)
```

Avant d'être projeté à travers un graphique. contenant les deux premières composantes

```{r}
DimPlot(data, reduction="pca")
```

A travers ce graphique toutes les données sont représentées avec un mélange indistinct des types cellulaires. Ici, aucun groupe n'est clairement mis en évidence. 

Afin de pouvoir effectuer une meilleure visualisation nous effectuons une clusterisation des données

## Clustering

```{r}
data <- FindNeighbors(data, dims=1:10)
data <- FindClusters(data, resolution=0.5)
```

```{r}
data <- RunUMAP(data, dims=1:10)

```

```{r}
DimPlot(data, reduction="umap")
```

Cette représentation permet de distinguer différents types cellulaires répartis le long des deux dimensions de la représentation UMAP. Un groupe en particulier se détache des autres (6) et semble être différents. Malgrè cela les types cellulaires même regroupé semble se distinguer. Afin que le traitement des données soit plus simple, nous avons décider de réduire nos données en 4 clusters.

#Affichage en fonction de 4 clusters

```{r}
resolution <- 0.1
data <- FindClusters(data, resolution = resolution)
while (length(unique(Idents(data))) != 4) {
  resolution <- resolution + 0.05
  data <- FindClusters(data, resolution = resolution)
}
cat("Résolution finale :", resolution, "avec", length(unique(Idents(data))), "clusters.\n")
DimPlot(data, reduction = "umap", group.by = "seurat_clusters")
DimPlot(data, reduction = "pca", group.by = "seurat_clusters")
```

Nous pouvons ainsi observer sur l'ACP que parmis les 4 clusters sélectionnés nous distinguons 3 types cellulaires qui se répartissent en 3 groupes (0, 1 et 2) le quatrième groupe (3) se confondant aux 3 autres.
Lorsque l'on regarde cette représentation en format UMAP nous pouvons observer 4 groupes bien distincts. Les types cellulaires 0,1 et 2 étant très proche l'un des autres et le cluster 3 qui est excentré par rapport à ce groupe. 

Etant données que nous disposons de groupe distinct au sein de l'UMAP nous allons ensuite chercher les gènes spécifiques à chacun de ces groupes afin de pouvoir identifier les types cellulaires présents

#Détermination des gènes spécifique à chaque groupe

```{r}
cluster2.markers <- FindMarkers(data, ident.1=2, min.pct=0.25)
head(cluster2.markers, n=5)
```
Ainsi parmi les gènes déterminé nous retrouvons les gènes suivants:
  - GZMB: (Granzime B) qui est exprimé par les lymphocytes T cytotoxique (CTL) et les cellules NK (Natural Killers)
  - JCHAIN (chaîne de jonction): qui est composant protéique exprimé dans les lymphocyte B.
  -LILRA4 (Leukocyte immunoglobulin-like receptor subfamily A member 4) : gène qui est préférentiellement exprimée dans les cellules dendritiques plasmacytoïdes (PDC).
  -ITM2C: EN COURS ARRET ICI

C'est gènes nous permettent ainsi de mettre en évidence à quel groupe immunitaire appartienne chaque type cellulaire de notre UMAP
  

#Recherche des marqueurs de gnène pour l'ensemble des population
```{r}
data.markers <- FindAllMarkers(data, only.pos=TRUE, min.pct=0.25, logfc.threshold=0.25)
```
```{r}
data.markers %>%
  group_by(cluster) %>%
  slice_max(n=2, order_by=avg_log2FC)
```
#A modifier

```{r}
VlnPlot(data, features = c("CXCL9", "SPP1","COL1A1"))
```

```{r}
FeaturePlot(data, features=c("GZMB"))
```
CD68 et CD14 spécifique des granulocytes et monocyte

```{r}
# Extraire les données de comptage normalisées
counts <- as.matrix(GetAssayData(data, layer = "counts"))
cluster.num <- as.numeric(Idents(data))

# Utiliser SingleCellSignalR pour détecter les interactions
LR.inter <- cell_signaling(counts, rownames(counts), cluster.num, c.names = new.cluster.ids)

# Visualiser toutes les interactions ligand-récepteur
visualize_interactions(LR.inter)

# Visualiser les interactions spécifiques pour un cluster donné (par ex., "Cluster 1")
#visualize_interactions(LR.inter, show.in = "C 1-C 3", "C 1-C 4")
print(LR.inter)
names(LR.inter)
```

```{r}
counts <- as.matrix(GetAssayData(object=data, slot="counts"))
counts[1:10,1:5]
q <- apply(counts, 2, function(x) quantile(x[x>0],0.99))
ncounts <- log(1+sweep(counts, 2, q/median(q), "/"))
ncounts[1:10,1:5]
cluster.num <- as.numeric(Idents(data))
LR.inter <- cell_signaling(ncounts, rownames(ncounts), cluster.num, c.names=new.cluster.ids)
visualize_interactions(LR.inter)
visualize_interactions(LR.inter, show.in=c("B-NK"))

```

se di que les 4 groupes sont répartie de

En combinaison avec le % de lectures mitochondriales, l'élimination des valeurs aberrantes de ces groupes permet de supprimer la plupart des doublets/cellules mortes/gouttelettes vides, ce qui explique pourquoi le filtrage est une étape de prétraitement courante.

